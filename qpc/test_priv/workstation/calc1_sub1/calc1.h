/*.$file${.::calc1.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: calc1_sub1.qm
* File:  ${.::calc1.h}
*
* This code has been generated by QM 4.6.0 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-EVAL
* Issued to   : Institution or an individual evaluating the QP/C framework
* Framework(s): qpc
* Support ends: 2020-12-31
* Product(s)  :
* This license is available only for evaluation purposes and
* the generated code is still licensed under the terms of GPL.
* Please submit request for extension of the evaluaion period at:
* https://www.state-machine.com/licensing/#RequestForm
*/
/*.$endhead${.::calc1.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifndef calc1_h
#define calc1_h

enum CalcSignals {
    C_SIG = Q_USER_SIG,
    CE_SIG,
    DIGIT_0_SIG,
    DIGIT_1_9_SIG,
    POINT_SIG,
    OPER_SIG,
    EQUALS_SIG,
    OFF_SIG
};

#define KEY_NULL    '\0'
#define KEY_PLUS    '+'
#define KEY_MINUS   '-'
#define KEY_MULT    '*'
#define KEY_DIVIDE  '/'

/*.$declare${Events::CalcEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::CalcEvt} ......................................................*/
typedef struct {
/* protected: */
    QEvt super;

/* public: */
    uint8_t key_code;
} CalcEvt;
/*.$enddecl${Events::CalcEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${SMs::Calc_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${SMs::Calc_ctor} .......................................................*/
void Calc_ctor(void);
/*.$enddecl${SMs::Calc_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${SMs::Calc} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${SMs::Calc} ............................................................*/
typedef struct Calc {
/* protected: */
    QMsm super;

/* private: */
    double op1;
    double op2;
    uint8_t oper1;
    uint8_t oper2;

/* public: */

/* private submachines */
    struct SM_operand {
        QMState super;
        QActionHandler const ce; /* eXit-Point segment */
    } const *sub_operand;
} Calc;

/* private: */

/* guard function to evaluate the current expression
* taking into account the precedence of operands.
* return: true if evaluation successfull
* false when error encountered
*/
bool Calc_eval(Calc * const me, double op, uint8_t oper);
extern Calc Calc_inst;

/* protected: */
QState Calc_initial(Calc * const me, QEvt const * const e);
QState Calc_on  (Calc * const me, QEvt const * const e);
QState Calc_on_e(Calc * const me);
QState Calc_on_x(Calc * const me);
QState Calc_on_i(Calc * const me);
extern QMState const Calc_on_s;

/* Error state after evaluation of an expression.
This state can be exited only throgh the inherited C (Clear) event.
*/
QState Calc_error  (Calc * const me, QEvt const * const e);
QState Calc_error_e(Calc * const me);
QState Calc_error_x(Calc * const me);
extern QMState const Calc_error_s;
QState Calc_ready  (Calc * const me, QEvt const * const e);
QState Calc_ready_e(Calc * const me);
QState Calc_ready_x(Calc * const me);
QState Calc_ready_i(Calc * const me);
extern QMState const Calc_ready_s;
QState Calc_result  (Calc * const me, QEvt const * const e);
QState Calc_result_e(Calc * const me);
QState Calc_result_x(Calc * const me);
extern QMState const Calc_result_s;
QState Calc_begin  (Calc * const me, QEvt const * const e);
QState Calc_begin_e(Calc * const me);
QState Calc_begin_x(Calc * const me);
extern QMState const Calc_begin_s;
QState Calc_opEntered  (Calc * const me, QEvt const * const e);
QState Calc_opEntered_e(Calc * const me);
QState Calc_opEntered_x(Calc * const me);
extern QMState const Calc_opEntered_s;
QState Calc_operand1  (Calc * const me, QEvt const * const e);
QState Calc_operand1_e(Calc * const me);
QState Calc_operand1_ce(Calc * const me);
extern struct SM_operand const Calc_operand1_s;
QState Calc_operand2  (Calc * const me, QEvt const * const e);
QState Calc_operand2_e(Calc * const me);
QState Calc_operand2_ce(Calc * const me);
extern struct SM_operand const Calc_operand2_s;
QState Calc_final  (Calc * const me, QEvt const * const e);
QState Calc_final_e(Calc * const me);
extern QMState const Calc_final_s;

QState Calc_operand  (Calc * const me, QEvt const * const e);
QState Calc_operand_e(Calc * const me);
QState Calc_operand_x(Calc * const me);
extern QMState const Calc_operand_s;
QState Calc_operand_zero_ep(Calc * const me);
QState Calc_operand_intgr_ep(Calc * const me);
QState Calc_operand_frac_ep(Calc * const me);
QState Calc_operand_neg_ep(Calc * const me);
QState Calc_operand_zero  (Calc * const me, QEvt const * const e);
QState Calc_operand_zero_e(Calc * const me);
QState Calc_operand_zero_x(Calc * const me);
extern QMState const Calc_operand_zero_s;
QState Calc_operand_int  (Calc * const me, QEvt const * const e);
QState Calc_operand_int_e(Calc * const me);
QState Calc_operand_int_x(Calc * const me);
extern QMState const Calc_operand_int_s;
QState Calc_operand_frac  (Calc * const me, QEvt const * const e);
QState Calc_operand_frac_e(Calc * const me);
QState Calc_operand_frac_x(Calc * const me);
extern QMState const Calc_operand_frac_s;
QState Calc_operand_negated  (Calc * const me, QEvt const * const e);
QState Calc_operand_negated_e(Calc * const me);
QState Calc_operand_negated_x(Calc * const me);
extern QMState const Calc_operand_negated_s;
/*.$enddecl${SMs::Calc} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

extern QHsm * const the_calc;  /* "opaque" pointer to calculator HSM */

#endif /* calc1_h */